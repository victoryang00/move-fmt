pub struct MoveParser;
# [allow (dead_code , non_camel_case_types)] # [derive (Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum Rule { EOI , grammar_rules , grammar_rule , line_terminator , WHITESPACE , COMMENT , alpha , digit , ident , field_name , procedure_name , module_name , struct_name , var , kind , ground_type , module_alias , base_type , ir_type , tau_list , unsigned , address , bytes , value , SENDER_address , value_operator , reference_operator , module_operator , builtin , builtin_start , call , cmd , equal , left_column , right_column , stmtx , stmt , literal_if , literal_while , literal_loop , literal_else , expx , exp , binary_exp , import_decl , struct_decl , procedure_body , procedure_decl , module_decl , transaction_script , move_script , script_def , address_def , module_def , moduleitem_item , const_def , nat_function_def , nat_struct_def , function_sig_withoptionalvisibility , function_sig_visibility , function_sig_ , function_def , function_visibilitymodifier , function_parameterlist , function_parameter , returntype , acquirestype , acquirestype_items , acquirestype_items_recover , struct_sig_ , struct_def , abilitieslist , ability , structfields_defblock , structfield_def , friend_stmt , import_stmt , module_import , module_items_import , multi_item_import , item_import , importalias , typeannotation , type_ , reftype , reftypestart , qual_pathtype , tupletype , lambdatype , typeparameterlist , typeparameter_with_recover , typeparameter_recover , typeparameter , typeparambound , typeparambound_items , typeargumentlist , _pat , wild_pat , deref_pat , borrow_pat , dot_pat , binding_pat , tuple_pat , struct_pat , struct_patfieldsblock , struct_patfield , struct_patfieldbinding , _stmt , let_stmt , _stmt_expr , anyblock , inlineblock , codeblock_expr , codeblock , codeblockitems , _expr , _exprx , _expr_op , controlflow_expr , unary_expr , atom_expr , annotatedexpprefix , annotated_expr , bang_expr , deref_expr , copy_expr , move_expr , return_expr , abort_expr , break_expr , continue_expr , structliteral_expr , structliteral_fieldsblock , structliteral_field , structliteral_fieldassignment , parens_expr , lambda_expr , range_expr , tupleliteral_expr , emptytuple_expr , tuple_expr , literal_expr , call_expr , callarguments , if_expr , condition , conditionbody , elseblock , loop_expr , while_expr , borrow_expr , dot_expr , structfieldref , index_expr , ref_expr , qual_path , moduleref , fullyqualifiedmoduleref , spec_def , schemaspec_def , function_spec_def , structspec_def , modulespec_def , _definefunction_sig_ , _definefunction_ , nat_definefunction_ , blockspec_stmt , specblock , specblock_stmt , specblockfinishing_expr , _definefunction_spec_def , nat_definefunction_spec_def , variable_stmt , localvariable_stmt , globalvariable_stmt , pragma_stmt , pragmaattribute , spec_expr , assume_stmt , assumespec_expr , assert_stmt , assertspec_expr , abortsif_stmt , abortsifspec_expr , with_expr , succeedsif_stmt , succeedsifspec_expr , requires_stmt , requiresspec_expr , ensures_stmt , ensuresspec_expr , modifies_stmt , modifiesspec_expr , include_stmt , function_pattern , invariant_stmt , invariantspec_expr , invariantmodifier , spec_visibility , spec_visibilitymodifier , emits_stmt , emits_condition , apply_stmt , apply_schema_name , apply_schema_name_attribute , predicate , aggregatepredicate_stmt , aggregate_expr , quant_where , quant_expr , forall_quant , exist_quant , quant_bindings , quant_bind } # [allow (clippy :: all)] impl :: pest :: Parser < Rule > for MoveParser { fn parse < 'i > (rule : Rule , input : & 'i str) -> :: std :: result :: Result < :: pest :: iterators :: Pairs < 'i , Rule > , :: pest :: error :: Error < Rule > > { mod rules { pub mod hidden { use super :: super :: Rule ; # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn skip (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { if state . atomicity () == :: pest :: Atomicity :: NonAtomic { state . sequence (| state | { state . repeat (| state | super :: visible :: WHITESPACE (state)) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: visible :: COMMENT (state) . and_then (| state | { state . repeat (| state | super :: visible :: WHITESPACE (state)) }) }) }) }) }) } else { Ok (state) } } } pub mod visible { use super :: super :: Rule ; # [inline] # [allow (non_snake_case , unused_variables)] pub fn grammar_rules (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . sequence (| state | { self :: SOI (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: grammar_rule (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: EOI (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn grammar_rule (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: grammar_rule , | state | { self :: module_decl (state) . or_else (| state | { self :: transaction_script (state) }) . or_else (| state | { self :: move_script (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn line_terminator (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . match_string ("\n") . or_else (| state | { state . match_string ("\r") }) . or_else (| state | { state . match_string ("\u{2028}") }) . or_else (| state | { state . match_string ("\u{2029}") }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn WHITESPACE (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string ("\t") . or_else (| state | { state . match_string ("\u{b}") }) . or_else (| state | { state . match_string ("\u{c}") }) . or_else (| state | { state . match_string (" ") }) . or_else (| state | { state . match_string ("\u{a0}") }) . or_else (| state | { state . match_string ("\u{feff}") }) . or_else (| state | { self :: SPACE_SEPARATOR (state) }) . or_else (| state | { self :: line_terminator (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn COMMENT (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("/*") . and_then (| state | { state . repeat (| state | { state . sequence (| state | { state . lookahead (false , | state | { state . match_string ("*/") }) . and_then (| state | { self :: ANY (state) }) }) }) }) . and_then (| state | { state . match_string ("*/") }) }) . or_else (| state | { state . sequence (| state | { state . match_string ("//") . and_then (| state | { state . repeat (| state | { self :: ANY (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn alpha (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: alpha , | state | { state . match_range ('a' .. 'z') . or_else (| state | { state . match_range ('A' .. 'Z') }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn digit (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: digit , | state | { state . match_range ('0' .. '9') }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn ident (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: ident , | state | { state . sequence (| state | { self :: alpha (state) . or_else (| state | { self :: digit (state) }) . or_else (| state | { state . match_string ("$") }) . or_else (| state | { state . match_string ("_") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: alpha (state) . or_else (| state | { self :: digit (state) }) . or_else (| state | { state . match_string ("$") }) . or_else (| state | { state . match_string ("_") }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: alpha (state) . or_else (| state | { self :: digit (state) }) . or_else (| state | { state . match_string ("$") }) . or_else (| state | { state . match_string ("_") }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn field_name (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: field_name , | state | { self :: ident (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn procedure_name (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: procedure_name , | state | { self :: ident (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn module_name (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: module_name , | state | { self :: ident (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn struct_name (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: struct_name , | state | { self :: ident (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn var (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: var , | state | { self :: ident (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn kind (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: kind , | state | { state . match_string ("R") . or_else (| state | { state . match_string ("V") }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn ground_type (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: ground_type , | state | { state . match_string ("bool") . or_else (| state | { state . match_string ("u8") }) . or_else (| state | { state . match_string ("u32") }) . or_else (| state | { state . match_string ("u64") }) . or_else (| state | { state . match_string ("u128") }) . or_else (| state | { state . match_string ("address") }) . or_else (| state | { state . match_string ("bytearray") }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn module_alias (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: module_alias , | state | { self :: module_name (state) . or_else (| state | { state . match_string ("Self") }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn base_type (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: base_type , | state | { self :: ground_type (state) . or_else (| state | { state . sequence (| state | { self :: kind (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("#") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: module_alias (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (".") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: struct_name (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn ir_type (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: ir_type , | state | { self :: base_type (state) . or_else (| state | { state . sequence (| state | { state . match_string ("&") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: base_type (state) }) }) }) . or_else (| state | { state . sequence (| state | { state . match_string ("&mut") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: base_type (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn tau_list (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: tau_list , | state | { state . match_string ("unit") . or_else (| state | { state . sequence (| state | { state . optional (| state | { self :: ir_type (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: ir_type (state) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn unsigned (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: unsigned , | state | { state . sequence (| state | { state . optional (| state | { self :: digit (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: digit (state) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn address (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: address , | state | { state . sequence (| state | { state . match_string ("0x") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . match_range ('0' .. '9') . or_else (| state | { state . match_range ('a' .. 'f') }) . or_else (| state | { state . match_range ('A' .. 'F') }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . match_range ('0' .. '9') . or_else (| state | { state . match_range ('a' .. 'f') }) . or_else (| state | { state . match_range ('A' .. 'F') }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn bytes (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: bytes , | state | { state . sequence (| state | { state . match_string ("b\"") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: alpha (state) . or_else (| state | { self :: digit (state) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: alpha (state) . or_else (| state | { self :: digit (state) }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("\"") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn value (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: value , | state | { state . match_string ("true") . or_else (| state | { state . match_string ("false") }) . or_else (| state | { self :: address (state) }) . or_else (| state | { self :: bytes (state) }) . or_else (| state | { self :: unsigned (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn SENDER_address (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: SENDER_address , | state | { state . match_string ("{{sender}}") }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn value_operator (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: value_operator , | state | { state . sequence (| state | { state . match_string ("copy") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: var (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) . or_else (| state | { state . sequence (| state | { state . match_string ("move") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: var (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn reference_operator (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: reference_operator , | state | { state . sequence (| state | { state . match_string ("&") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: var (state) }) }) . or_else (| state | { state . sequence (| state | { state . match_string ("&") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (".") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: field_name (state) }) }) }) . or_else (| state | { state . sequence (| state | { state . match_string ("*") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn module_operator (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: module_operator , | state | { state . sequence (| state | { state . match_string ("move_from") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("<") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: struct_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (">") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) . or_else (| state | { state . sequence (| state | { state . match_string ("borrow_global") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("<") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: struct_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (">") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) . or_else (| state | { state . sequence (| state | { state . match_string ("exist") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("<") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: struct_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (">") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn builtin (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: builtin , | state | { state . sequence (| state | { self :: builtin_start (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn builtin_start (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: builtin_start , | state | { state . match_string ("create_account") . or_else (| state | { state . match_string ("release") }) . or_else (| state | { state . match_string ("freeze") }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn call (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: call , | state | { self :: module_operator (state) . or_else (| state | { self :: builtin (state) }) . or_else (| state | { state . sequence (| state | { self :: module_alias (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (".") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: procedure_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: exp (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: exp (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn cmd (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: cmd , | state | { state . sequence (| state | { self :: var (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: equal (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: call (state) }) }) . or_else (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { self :: var (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: var (state) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: equal (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) }) }) . or_else (| state | { self :: call (state) }) . or_else (| state | { state . sequence (| state | { state . match_string ("*") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: var (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: equal (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) }) }) . or_else (| state | { state . sequence (| state | { state . match_string ("assert") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) . or_else (| state | { state . match_string ("break") }) . or_else (| state | { state . match_string ("continue") }) . or_else (| state | { state . sequence (| state | { state . match_string ("return") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: exp (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: exp (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) }) }) }) }) }) . or_else (| state | { state . sequence (| state | { self :: struct_name (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: field_name (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: var (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: field_name (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: var (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: field_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: var (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: equal (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn equal (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: equal , | state | { state . match_string ("=") }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn left_column (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: left_column , | state | { state . match_string ("(") }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn right_column (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: right_column , | state | { state . match_string (")") }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn stmtx (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: stmtx , | state | { state . sequence (| state | { self :: stmt (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: stmtx (state) }) }) . or_else (| state | { self :: stmt (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: stmt , | state | { state . sequence (| state | { self :: literal_if (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: stmtx (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: literal_else (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: stmtx (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) . or_else (| state | { state . sequence (| state | { self :: literal_if (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: stmtx (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) . or_else (| state | { state . sequence (| state | { self :: literal_while (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: stmtx (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) . or_else (| state | { state . sequence (| state | { self :: literal_loop (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: stmtx (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) . or_else (| state | { state . sequence (| state | { self :: cmd (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn literal_if (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: literal_if , | state | { state . match_string ("if") }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn literal_while (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: literal_while , | state | { state . match_string ("while") }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn literal_loop (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: literal_loop , | state | { state . match_string ("loop") }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn literal_else (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: literal_else , | state | { state . match_string ("else") }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn expx (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: expx , | state | { self :: value_operator (state) . or_else (| state | { self :: reference_operator (state) }) . or_else (| state | { state . sequence (| state | { self :: struct_name (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: field_name (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: expx (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: field_name (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: expx (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) . or_else (| state | { state . sequence (| state | { state . match_string ("!") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: expx (state) }) }) }) . or_else (| state | { self :: value (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn exp (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: exp , | state | { state . sequence (| state | { self :: expx (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: binary_exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) }) . or_else (| state | { state . sequence (| state | { self :: left_column (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) }) }) . or_else (| state | { state . sequence (| state | { self :: left_column (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: exp (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) . or_else (| state | { self :: expx (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn binary_exp (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: binary_exp , | state | { state . match_string ("||") . or_else (| state | { state . match_string ("&&") }) . or_else (| state | { state . match_string (">=") }) . or_else (| state | { state . match_string ("<=") }) . or_else (| state | { state . match_string (">") }) . or_else (| state | { state . match_string ("<") }) . or_else (| state | { state . match_string ("+") }) . or_else (| state | { state . match_string ("-") }) . or_else (| state | { state . match_string ("*") }) . or_else (| state | { state . match_string ("/") }) . or_else (| state | { state . match_string ("*") }) . or_else (| state | { state . match_string ("%") }) . or_else (| state | { state . match_string ("^") }) . or_else (| state | { state . match_string ("|") }) . or_else (| state | { state . match_string ("&") }) . or_else (| state | { state . match_string ("==") }) . or_else (| state | { state . match_string ("!=") }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn import_decl (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: import_decl , | state | { state . sequence (| state | { state . match_string ("import") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: address (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (".") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: module_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . match_string ("as") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: module_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) . or_else (| state | { state . match_string (";") }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn struct_decl (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: struct_decl , | state | { state . sequence (| state | { state . match_string ("resourse") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: struct_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: field_name (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: base_type (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: field_name (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: base_type (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: field_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: base_type (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (" }") }) }) . or_else (| state | { state . sequence (| state | { state . match_string ("struct") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: struct_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: field_name (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: base_type (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: field_name (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: base_type (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: field_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: base_type (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn procedure_body (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: procedure_body , | state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . match_string ("let") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: var (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (":") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ground_type (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . match_string ("let") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: var (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (":") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ground_type (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: stmtx (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn procedure_decl (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: procedure_decl , | state | { state . sequence (| state | { state . optional (| state | { state . match_string ("public") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: procedure_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: var (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ir_type (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: var (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ir_type (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: var (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ir_type (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: tau_list (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: procedure_body (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) . or_else (| state | { state . sequence (| state | { state . match_string ("native") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . match_string ("public") }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: procedure_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: var (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ir_type (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: var (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ir_type (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: var (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ir_type (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: tau_list (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn module_decl (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: module_decl , | state | { state . sequence (| state | { state . match_string ("module") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: module_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: import_decl (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: import_decl (state) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: struct_decl (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: struct_decl (state) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: procedure_decl (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: procedure_decl (state) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn transaction_script (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: transaction_script , | state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { self :: import_decl (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: import_decl (state) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("public") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("main") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: left_column (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: var (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ground_type (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: var (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ground_type (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: var (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ground_type (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn move_script (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: move_script , | state | { state . sequence (| state | { state . optional (| state | { self :: script_def (state) . or_else (| state | { self :: address_def (state) }) . or_else (| state | { self :: module_def (state) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: script_def (state) . or_else (| state | { self :: address_def (state) }) . or_else (| state | { self :: module_def (state) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn script_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: script_def , | state | { state . sequence (| state | { state . match_string ("script") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: import_stmt (state) . or_else (| state | { self :: const_def (state) }) . or_else (| state | { self :: function_def (state) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: import_stmt (state) . or_else (| state | { self :: const_def (state) }) . or_else (| state | { self :: function_def (state) }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn address_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: address_def , | state | { state . sequence (| state | { state . match_string ("address") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: address (state) . or_else (| state | { self :: SENDER_address (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: module_def (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: module_def (state) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn module_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: module_def , | state | { state . sequence (| state | { state . match_string ("module") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("{") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: moduleitem_item (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: moduleitem_item (state) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn moduleitem_item (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: moduleitem_item , | state | { self :: import_stmt (state) . or_else (| state | { self :: friend_stmt (state) }) . or_else (| state | { self :: struct_def (state) }) . or_else (| state | { self :: function_def (state) }) . or_else (| state | { self :: nat_struct_def (state) }) . or_else (| state | { self :: nat_function_def (state) }) . or_else (| state | { self :: const_def (state) }) . or_else (| state | { self :: spec_def (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn const_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: const_def , | state | { state . sequence (| state | { state . match_string ("const") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: typeannotation (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: equal (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn nat_function_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: nat_function_def , | state | { state . sequence (| state | { state . match_string ("native") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: function_sig_withoptionalvisibility (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn nat_struct_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: nat_struct_def , | state | { state . sequence (| state | { state . match_string ("native") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: struct_sig_ (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn function_sig_withoptionalvisibility (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: function_sig_withoptionalvisibility , | state | { self :: function_sig_visibility (state) . or_else (| state | { self :: function_sig_ (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn function_sig_visibility (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: function_sig_visibility , | state | { state . sequence (| state | { self :: function_visibilitymodifier (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: function_sig_ (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn function_sig_ (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: function_sig_ , | state | { state . sequence (| state | { state . match_string ("fun") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: typeparameterlist (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: function_parameterlist (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: returntype (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: acquirestype (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn function_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: function_def , | state | { state . sequence (| state | { self :: function_sig_withoptionalvisibility (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: codeblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn function_visibilitymodifier (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: function_visibilitymodifier , | state | { state . sequence (| state | { state . match_string ("public") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { self :: left_column (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("script") . or_else (| state | { state . match_string ("friend") }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn function_parameterlist (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: function_parameterlist , | state | { state . sequence (| state | { self :: left_column (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: function_parameter (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: function_parameter (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: function_parameter (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn function_parameter (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: function_parameter , | state | { state . sequence (| state | { self :: ident (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: typeannotation (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn returntype (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: returntype , | state | { state . sequence (| state | { state . match_string (":") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: type_ (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn acquirestype (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: acquirestype , | state | { state . sequence (| state | { state . match_string ("acquires") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: acquirestype_items (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn acquirestype_items (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: acquirestype_items , | state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: qual_pathtype (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: qual_pathtype (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: qual_pathtype (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn acquirestype_items_recover (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: acquirestype_items_recover , | state | { state . lookahead (false , | state | { state . match_string (";") . or_else (| state | { state . match_string ("{") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn struct_sig_ (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: struct_sig_ , | state | { state . sequence (| state | { state . match_string ("struct") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: typeparameterlist (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: abilitieslist (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn struct_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: struct_def , | state | { state . sequence (| state | { self :: struct_sig_ (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: structfields_defblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn abilitieslist (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: abilitieslist , | state | { state . sequence (| state | { state . match_string ("has") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: ability (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: ability (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ability (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn ability (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: ability , | state | { state . match_string ("copy") . or_else (| state | { self :: ident (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn structfields_defblock (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: structfields_defblock , | state | { state . sequence (| state | { state . match_string ("{") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: structfield_def (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: structfield_def (state) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn structfield_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: structfield_def , | state | { state . sequence (| state | { self :: ident (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: typeannotation (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") . or_else (| state | { state . match_string ("}") }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn friend_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: friend_stmt , | state | { state . sequence (| state | { state . match_string ("friend") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: fullyqualifiedmoduleref (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn import_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: import_stmt , | state | { state . sequence (| state | { state . match_string ("use") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: module_items_import (state) . or_else (| state | { self :: module_import (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn module_import (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: module_import , | state | { state . sequence (| state | { self :: fullyqualifiedmoduleref (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: importalias (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn module_items_import (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: module_items_import , | state | { state . sequence (| state | { self :: fullyqualifiedmoduleref (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("::") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: item_import (state) . or_else (| state | { self :: multi_item_import (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn multi_item_import (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: multi_item_import , | state | { state . sequence (| state | { state . match_string ("{") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: item_import (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: item_import (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: item_import (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn item_import (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: item_import , | state | { state . sequence (| state | { self :: ident (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: importalias (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn importalias (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: importalias , | state | { state . sequence (| state | { state . match_string ("as") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn typeannotation (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: typeannotation , | state | { state . sequence (| state | { state . match_string (":") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: type_ (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn type_ (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: type_ , | state | { self :: reftype (state) . or_else (| state | { self :: qual_pathtype (state) }) . or_else (| state | { self :: tupletype (state) }) . or_else (| state | { self :: lambdatype (state) }) . or_else (| state | { self :: ident (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn reftype (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: reftype , | state | { state . sequence (| state | { self :: reftypestart (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: type_ (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn reftypestart (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: reftypestart , | state | { state . sequence (| state | { state . match_string ("&") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . match_string ("mut") }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn qual_pathtype (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: qual_pathtype , | state | { self :: qual_path (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn tupletype (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: tupletype , | state | { state . sequence (| state | { self :: left_column (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: type_ (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: type_ (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: type_ (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: type_ (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn lambdatype (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: lambdatype , | state | { state . sequence (| state | { state . match_string ("|") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: type_ (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: type_ (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: type_ (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("|") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: type_ (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn typeparameterlist (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: typeparameterlist , | state | { state . sequence (| state | { state . match_string ("<") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: typeparameter_with_recover (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: typeparameter_with_recover (state) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (">") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn typeparameter_with_recover (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: typeparameter_with_recover , | state | { state . sequence (| state | { state . lookahead (false , | state | { state . match_string (">") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: typeparameter (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") . or_else (| state | { state . lookahead (true , | state | { state . match_string (">") }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn typeparameter_recover (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: typeparameter_recover , | state | { state . lookahead (false , | state | { state . match_string (">") . or_else (| state | { self :: left_column (state) }) . or_else (| state | { state . match_string ("{") }) . or_else (| state | { self :: ident (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn typeparameter (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: typeparameter , | state | { state . sequence (| state | { self :: ident (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: typeparambound (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn typeparambound (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: typeparambound , | state | { state . sequence (| state | { state . match_string (":") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: typeparambound_items (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn typeparambound_items (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: typeparambound_items , | state | { state . sequence (| state | { self :: ability (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . match_string ("+") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ability (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . match_string ("+") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ability (state) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn typeargumentlist (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: typeargumentlist , | state | { state . sequence (| state | { state . match_string ("<") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: type_ (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: type_ (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: type_ (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (">") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn _pat (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: _pat , | state | { self :: deref_pat (state) . or_else (| state | { self :: borrow_pat (state) }) . or_else (| state | { self :: tuple_pat (state) }) . or_else (| state | { self :: struct_pat (state) }) . or_else (| state | { self :: dot_pat (state) }) . or_else (| state | { self :: wild_pat (state) }) . or_else (| state | { self :: binding_pat (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn wild_pat (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: wild_pat , | state | { state . match_string ("~_") }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn deref_pat (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: deref_pat , | state | { state . sequence (| state | { state . match_string ("*") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _pat (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn borrow_pat (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: borrow_pat , | state | { state . sequence (| state | { state . match_string ("&") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _pat (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn dot_pat (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: dot_pat , | state | { state . sequence (| state | { self :: ident (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (".") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn binding_pat (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: binding_pat , | state | { self :: ident (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn tuple_pat (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: tuple_pat , | state | { state . sequence (| state | { self :: left_column (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: _pat (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: _pat (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _pat (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn struct_pat (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: struct_pat , | state | { state . sequence (| state | { self :: qual_path (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: struct_patfieldsblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn struct_patfieldsblock (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: struct_patfieldsblock , | state | { state . sequence (| state | { state . match_string ("{") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: struct_patfield (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: struct_patfield (state) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn struct_patfield (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: struct_patfield , | state | { state . sequence (| state | { self :: ident (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: struct_patfieldbinding (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn struct_patfieldbinding (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: struct_patfieldbinding , | state | { state . sequence (| state | { state . match_string (":") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _pat (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn _stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: _stmt , | state | { self :: let_stmt (state) . or_else (| state | { state . sequence (| state | { self :: _stmt_expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn let_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: let_stmt , | state | { state . sequence (| state | { state . match_string ("let") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _pat (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: typeannotation (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { self :: equal (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn _stmt_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: _stmt_expr , | state | { self :: if_expr (state) . or_else (| state | { self :: loop_expr (state) }) . or_else (| state | { self :: while_expr (state) }) . or_else (| state | { self :: _expr (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn anyblock (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: anyblock , | state | { self :: codeblock (state) . or_else (| state | { self :: inlineblock (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn inlineblock (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: inlineblock , | state | { self :: _expr (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn codeblock_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: codeblock_expr , | state | { self :: codeblock (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn codeblock (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: codeblock , | state | { state . sequence (| state | { state . match_string ("{") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: codeblockitems (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn codeblockitems (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: codeblockitems , | state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { self :: import_stmt (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: import_stmt (state) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: _stmt (state) . or_else (| state | { self :: blockspec_stmt (state) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: _stmt (state) . or_else (| state | { self :: blockspec_stmt (state) }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: _expr (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn _expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: _expr , | state | { self :: controlflow_expr (state) . or_else (| state | { self :: unary_expr (state) }) . or_else (| state | { self :: borrow_expr (state) }) . or_else (| state | { self :: atom_expr (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn _exprx (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: _exprx , | state | { state . sequence (| state | { self :: call_expr (state) . or_else (| state | { self :: ident (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: _expr_op (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) . or_else (| state | { self :: ident (state) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: _expr_op (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) . or_else (| state | { self :: ident (state) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn _expr_op (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: _expr_op , | state | { state . match_string ("==") . or_else (| state | { state . match_string ("!=") }) . or_else (| state | { state . match_string ("<=") }) . or_else (| state | { state . match_string (">=") }) . or_else (| state | { state . match_string (">") }) . or_else (| state | { state . match_string ("<") }) . or_else (| state | { state . match_string ("||") }) . or_else (| state | { state . match_string ("&&") }) . or_else (| state | { state . match_string ("|") }) . or_else (| state | { state . match_string ("&") }) . or_else (| state | { state . match_string ("^") }) . or_else (| state | { state . match_string ("as") }) . or_else (| state | { state . match_string ("*") }) . or_else (| state | { state . match_string ("/") }) . or_else (| state | { state . match_string ("+") }) . or_else (| state | { state . match_string ("-") }) . or_else (| state | { state . match_string ("%") }) . or_else (| state | { state . match_string ("<<") }) . or_else (| state | { state . match_string (">>") }) . or_else (| state | { state . match_string ("==>") }) . or_else (| state | { state . match_string ("<==>") }) . or_else (| state | { state . match_string ("=") }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn controlflow_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: controlflow_expr , | state | { self :: if_expr (state) . or_else (| state | { self :: loop_expr (state) }) . or_else (| state | { self :: while_expr (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn unary_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: unary_expr , | state | { self :: copy_expr (state) . or_else (| state | { self :: move_expr (state) }) . or_else (| state | { self :: deref_expr (state) }) . or_else (| state | { self :: bang_expr (state) }) . or_else (| state | { self :: return_expr (state) }) . or_else (| state | { self :: continue_expr (state) }) . or_else (| state | { self :: break_expr (state) }) . or_else (| state | { self :: abort_expr (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn atom_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: atom_expr , | state | { self :: annotated_expr (state) . or_else (| state | { self :: tupleliteral_expr (state) }) . or_else (| state | { self :: parens_expr (state) }) . or_else (| state | { self :: structliteral_expr (state) }) . or_else (| state | { self :: dot_expr (state) }) . or_else (| state | { self :: index_expr (state) }) . or_else (| state | { self :: call_expr (state) }) . or_else (| state | { self :: ref_expr (state) }) . or_else (| state | { self :: lambda_expr (state) }) . or_else (| state | { self :: range_expr (state) }) . or_else (| state | { self :: codeblock_expr (state) }) . or_else (| state | { self :: literal_expr (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn annotatedexpprefix (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: annotatedexpprefix , | state | { state . sequence (| state | { self :: left_column (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn annotated_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: annotated_expr , | state | { state . sequence (| state | { self :: annotatedexpprefix (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: type_ (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn bang_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: bang_expr , | state | { state . sequence (| state | { state . match_string ("!") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn deref_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: deref_expr , | state | { state . sequence (| state | { state . match_string ("*") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn copy_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: copy_expr , | state | { state . sequence (| state | { state . match_string ("copy") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn move_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: move_expr , | state | { state . sequence (| state | { state . match_string ("move") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) . or_else (| state | { state . sequence (| state | { state . match_string ("move_to") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn return_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: return_expr , | state | { state . sequence (| state | { state . match_string ("return") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: _expr (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn abort_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: abort_expr , | state | { state . sequence (| state | { state . match_string ("abort") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn break_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: break_expr , | state | { state . match_string ("break") }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn continue_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: continue_expr , | state | { state . match_string ("continue") }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn structliteral_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: structliteral_expr , | state | { state . sequence (| state | { self :: qual_path (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: structliteral_fieldsblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn structliteral_fieldsblock (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: structliteral_fieldsblock , | state | { state . sequence (| state | { state . match_string ("{") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: structliteral_field (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: structliteral_field (state) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn structliteral_field (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: structliteral_field , | state | { state . sequence (| state | { self :: ident (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: structliteral_fieldassignment (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn structliteral_fieldassignment (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: structliteral_fieldassignment , | state | { state . sequence (| state | { state . match_string (":") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn parens_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: parens_expr , | state | { state . sequence (| state | { self :: left_column (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn lambda_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: lambda_expr , | state | { state . sequence (| state | { state . match_string ("|") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: ident (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: ident (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("|") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn range_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: range_expr , | state | { state . sequence (| state | { self :: _exprx (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("..") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn tupleliteral_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: tupleliteral_expr , | state | { self :: emptytuple_expr (state) . or_else (| state | { self :: tuple_expr (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn emptytuple_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: emptytuple_expr , | state | { state . sequence (| state | { self :: left_column (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn tuple_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: tuple_expr , | state | { state . sequence (| state | { self :: left_column (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: _expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: _expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn literal_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: literal_expr , | state | { self :: SENDER_address (state) . or_else (| state | { self :: address (state) }) . or_else (| state | { self :: value (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn call_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: call_expr , | state | { state . sequence (| state | { self :: qual_path (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: callarguments (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn callarguments (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: callarguments , | state | { state . sequence (| state | { self :: left_column (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { self :: _expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (",") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . match_string (",") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) }) }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn if_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: if_expr , | state | { state . sequence (| state | { self :: literal_if (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: condition (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: anyblock (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: elseblock (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn condition (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: condition , | state | { state . sequence (| state | { self :: left_column (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: conditionbody (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: right_column (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn conditionbody (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: conditionbody , | state | { self :: _expr (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn elseblock (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: elseblock , | state | { state . sequence (| state | { state . match_string ("else") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: anyblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn loop_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: loop_expr , | state | { state . sequence (| state | { state . match_string ("loop") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: anyblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn while_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: while_expr , | state | { state . sequence (| state | { state . match_string ("while") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: condition (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: anyblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn borrow_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: borrow_expr , | state | { state . sequence (| state | { state . match_string ("&") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . match_string ("mut") }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn dot_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: dot_expr , | state | { state . sequence (| state | { self :: _exprx (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (".") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: structfieldref (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn structfieldref (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: structfieldref , | state | { self :: ident (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn index_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: index_expr , | state | { state . sequence (| state | { self :: _exprx (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("[") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("]") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn ref_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: ref_expr , | state | { self :: qual_path (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn qual_path (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: qual_path , | state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: moduleref (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("::") }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: typeargumentlist (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn moduleref (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: moduleref , | state | { self :: ident (state) . or_else (| state | { self :: fullyqualifiedmoduleref (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn fullyqualifiedmoduleref (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: fullyqualifiedmoduleref , | state | { state . sequence (| state | { self :: SENDER_address (state) . or_else (| state | { self :: address (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("::") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn spec_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: spec_def , | state | { self :: function_spec_def (state) . or_else (| state | { self :: modulespec_def (state) }) . or_else (| state | { self :: structspec_def (state) }) . or_else (| state | { self :: schemaspec_def (state) }) . or_else (| state | { self :: _definefunction_spec_def (state) }) . or_else (| state | { self :: nat_definefunction_spec_def (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn schemaspec_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: schemaspec_def , | state | { state . sequence (| state | { state . match_string ("spec") . or_else (| state | { state . match_string ("schema") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: typeparameterlist (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: specblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn function_spec_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: function_spec_def , | state | { state . sequence (| state | { state . match_string ("spec") . or_else (| state | { state . match_string ("fun") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: specblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn structspec_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: structspec_def , | state | { state . sequence (| state | { state . match_string ("spec") . or_else (| state | { state . match_string ("struct") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: specblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn modulespec_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: modulespec_def , | state | { state . sequence (| state | { state . match_string ("spec") . or_else (| state | { state . match_string ("module") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: specblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn _definefunction_sig_ (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: _definefunction_sig_ , | state | { state . sequence (| state | { state . match_string ("define") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: typeparameterlist (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: function_parameterlist (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: returntype (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn _definefunction_ (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: _definefunction_ , | state | { state . sequence (| state | { self :: _definefunction_sig_ (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: specblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn nat_definefunction_ (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: nat_definefunction_ , | state | { state . sequence (| state | { self :: _definefunction_sig_ (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn blockspec_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: blockspec_stmt , | state | { state . sequence (| state | { state . match_string ("spec") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: specblock (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn specblock (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: specblock , | state | { state . sequence (| state | { state . match_string ("{") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: specblock_stmt (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: specblock_stmt (state) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: specblockfinishing_expr (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn specblock_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: specblock_stmt , | state | { self :: variable_stmt (state) . or_else (| state | { self :: localvariable_stmt (state) }) . or_else (| state | { self :: globalvariable_stmt (state) }) . or_else (| state | { self :: import_stmt (state) }) . or_else (| state | { self :: nat_function_def (state) }) . or_else (| state | { self :: _definefunction_ (state) }) . or_else (| state | { self :: _definefunction_spec_def (state) }) . or_else (| state | { self :: nat_definefunction_ (state) }) . or_else (| state | { self :: nat_definefunction_spec_def (state) }) . or_else (| state | { self :: pragma_stmt (state) }) . or_else (| state | { self :: assume_stmt (state) }) . or_else (| state | { self :: assert_stmt (state) }) . or_else (| state | { self :: abortsif_stmt (state) }) . or_else (| state | { self :: succeedsif_stmt (state) }) . or_else (| state | { self :: requires_stmt (state) }) . or_else (| state | { self :: ensures_stmt (state) }) . or_else (| state | { self :: modifies_stmt (state) }) . or_else (| state | { self :: include_stmt (state) }) . or_else (| state | { self :: invariant_stmt (state) }) . or_else (| state | { self :: apply_stmt (state) }) . or_else (| state | { self :: emits_stmt (state) }) . or_else (| state | { self :: aggregatepredicate_stmt (state) }) . or_else (| state | { self :: _stmt (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn specblockfinishing_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: specblockfinishing_expr , | state | { self :: spec_expr (state) . or_else (| state | { self :: aggregate_expr (state) }) . or_else (| state | { self :: _exprx (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn _definefunction_spec_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: _definefunction_spec_def , | state | { state . sequence (| state | { state . match_string ("spec") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _definefunction_sig_ (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: specblock (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn nat_definefunction_spec_def (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: nat_definefunction_spec_def , | state | { state . sequence (| state | { state . match_string ("spec") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _definefunction_sig_ (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn variable_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: variable_stmt , | state | { state . sequence (| state | { self :: ref_expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: typeannotation (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn localvariable_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: localvariable_stmt , | state | { state . sequence (| state | { state . match_string ("local") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ref_expr (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: typeannotation (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn globalvariable_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: globalvariable_stmt , | state | { state . sequence (| state | { state . match_string ("global") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ref_expr (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: typeannotation (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn pragma_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: pragma_stmt , | state | { state . sequence (| state | { state . match_string ("pragma") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: pragmaattribute (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: pragmaattribute (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: pragmaattribute (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn pragmaattribute (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: pragmaattribute , | state | { state . sequence (| state | { self :: ident (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { self :: equal (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: literal_expr (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn spec_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: spec_expr , | state | { self :: assumespec_expr (state) . or_else (| state | { self :: assertspec_expr (state) }) . or_else (| state | { self :: abortsifspec_expr (state) }) . or_else (| state | { self :: succeedsifspec_expr (state) }) . or_else (| state | { self :: requiresspec_expr (state) }) . or_else (| state | { self :: ensuresspec_expr (state) }) . or_else (| state | { self :: modifiesspec_expr (state) }) . or_else (| state | { self :: invariantspec_expr (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn assume_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: assume_stmt , | state | { state . sequence (| state | { self :: assumespec_expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn assumespec_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: assumespec_expr , | state | { state . sequence (| state | { state . match_string ("assume") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: predicate (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn assert_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: assert_stmt , | state | { state . sequence (| state | { self :: assertspec_expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn assertspec_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: assertspec_expr , | state | { state . sequence (| state | { state . match_string ("assert") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: predicate (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn abortsif_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: abortsif_stmt , | state | { state . sequence (| state | { self :: abortsifspec_expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn abortsifspec_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: abortsifspec_expr , | state | { state . sequence (| state | { state . match_string ("aborts_if") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: predicate (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: with_expr (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn with_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: with_expr , | state | { state . sequence (| state | { state . match_string ("with") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _exprx (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn succeedsif_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: succeedsif_stmt , | state | { state . sequence (| state | { self :: succeedsifspec_expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn succeedsifspec_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: succeedsifspec_expr , | state | { state . sequence (| state | { state . match_string ("succeeds_if") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: predicate (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn requires_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: requires_stmt , | state | { state . sequence (| state | { self :: requiresspec_expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn requiresspec_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: requiresspec_expr , | state | { state . sequence (| state | { state . match_string ("requires") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . match_string ("module") }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: predicate (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn ensures_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: ensures_stmt , | state | { state . sequence (| state | { self :: ensuresspec_expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn ensuresspec_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: ensuresspec_expr , | state | { state . sequence (| state | { state . match_string ("ensures") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: predicate (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn modifies_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: modifies_stmt , | state | { state . sequence (| state | { self :: modifiesspec_expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn modifiesspec_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: modifiesspec_expr , | state | { state . sequence (| state | { state . match_string ("modifies") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn include_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: include_stmt , | state | { state . sequence (| state | { state . match_string ("include") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: spec_visibility (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn function_pattern (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: function_pattern , | state | { state . sequence (| state | { state . optional (| state | { state . match_string ("public") . or_else (| state | { state . match_string ("internal") }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: ident (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: typeargumentlist (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn invariant_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: invariant_stmt , | state | { state . sequence (| state | { self :: invariantspec_expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn invariantspec_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: invariantspec_expr , | state | { state . sequence (| state | { state . match_string ("invariant") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: invariantmodifier (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: predicate (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn invariantmodifier (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: invariantmodifier , | state | { state . match_string ("pack") . or_else (| state | { state . match_string ("unpack") }) . or_else (| state | { state . match_string ("module") }) . or_else (| state | { state . match_string ("update") }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn spec_visibility (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: spec_visibility , | state | { state . sequence (| state | { state . match_string ("[") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: spec_visibilitymodifier (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: spec_visibilitymodifier (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: spec_visibilitymodifier (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("]") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn spec_visibilitymodifier (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: spec_visibilitymodifier , | state | { state . match_string ("global") . or_else (| state | { state . match_string ("isolated") }) . or_else (| state | { state . match_string ("deactivated") }) . or_else (| state | { state . match_string ("concrete") }) . or_else (| state | { state . match_string ("abstract") }) . or_else (| state | { state . match_string ("assert") }) . or_else (| state | { state . match_string ("assume") }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn emits_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: emits_stmt , | state | { state . sequence (| state | { state . match_string ("emits") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("to") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: emits_condition (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn emits_condition (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: emits_condition , | state | { state . sequence (| state | { self :: literal_if (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn apply_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: apply_stmt , | state | { state . sequence (| state | { state . match_string ("apply") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: apply_schema_name (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("to") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: function_pattern (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: function_pattern (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: function_pattern (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . match_string ("except") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: function_pattern (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: function_pattern (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: function_pattern (state) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn apply_schema_name (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: apply_schema_name , | state | { state . sequence (| state | { self :: qual_path (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . match_string ("{") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: apply_schema_name_attribute (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: apply_schema_name_attribute (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: apply_schema_name_attribute (state) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("}") }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn apply_schema_name_attribute (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: apply_schema_name_attribute , | state | { state . sequence (| state | { self :: ident (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _exprx (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn predicate (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: predicate , | state | { state . sequence (| state | { state . optional (| state | { self :: spec_visibility (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: aggregate_expr (state) . or_else (| state | { self :: _exprx (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn aggregatepredicate_stmt (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: aggregatepredicate_stmt , | state | { state . sequence (| state | { self :: aggregate_expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (";") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn aggregate_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: aggregate_expr , | state | { state . sequence (| state | { self :: quant_expr (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (":") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn quant_where (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: quant_where , | state | { state . sequence (| state | { state . match_string ("where") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: _expr (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn quant_expr (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: quant_expr , | state | { self :: forall_quant (state) . or_else (| state | { self :: exist_quant (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn forall_quant (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: forall_quant , | state | { state . sequence (| state | { state . match_string ("forall") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: quant_bindings (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: quant_where (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (":") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: quant_expr (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn exist_quant (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: exist_quant , | state | { state . sequence (| state | { state . match_string ("exists") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: quant_bindings (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { self :: quant_where (state) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (":") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: quant_expr (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn quant_bindings (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: quant_bindings , | state | { state . optional (| state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { self :: quant_bind (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { self :: quant_bind (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: quant_bind (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn quant_bind (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: quant_bind , | state | { state . sequence (| state | { self :: ident (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . match_string ("in") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: range_expr (state) }) }) . or_else (| state | { state . sequence (| state | { state . match_string (":") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: type_ (state) }) }) }) }) }) }) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn ANY (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . skip (1) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn EOI (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: EOI , | state | state . end_of_input ()) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn SOI (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . start_of_input () } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] fn SPACE_SEPARATOR (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . match_char_by (:: pest :: unicode :: SPACE_SEPARATOR) } } pub use self :: visible :: * ; } :: pest :: state (input , | state | { match rule { Rule :: grammar_rules => rules :: grammar_rules (state) , Rule :: grammar_rule => rules :: grammar_rule (state) , Rule :: line_terminator => rules :: line_terminator (state) , Rule :: WHITESPACE => rules :: WHITESPACE (state) , Rule :: COMMENT => rules :: COMMENT (state) , Rule :: alpha => rules :: alpha (state) , Rule :: digit => rules :: digit (state) , Rule :: ident => rules :: ident (state) , Rule :: field_name => rules :: field_name (state) , Rule :: procedure_name => rules :: procedure_name (state) , Rule :: module_name => rules :: module_name (state) , Rule :: struct_name => rules :: struct_name (state) , Rule :: var => rules :: var (state) , Rule :: kind => rules :: kind (state) , Rule :: ground_type => rules :: ground_type (state) , Rule :: module_alias => rules :: module_alias (state) , Rule :: base_type => rules :: base_type (state) , Rule :: ir_type => rules :: ir_type (state) , Rule :: tau_list => rules :: tau_list (state) , Rule :: unsigned => rules :: unsigned (state) , Rule :: address => rules :: address (state) , Rule :: bytes => rules :: bytes (state) , Rule :: value => rules :: value (state) , Rule :: SENDER_address => rules :: SENDER_address (state) , Rule :: value_operator => rules :: value_operator (state) , Rule :: reference_operator => rules :: reference_operator (state) , Rule :: module_operator => rules :: module_operator (state) , Rule :: builtin => rules :: builtin (state) , Rule :: builtin_start => rules :: builtin_start (state) , Rule :: call => rules :: call (state) , Rule :: cmd => rules :: cmd (state) , Rule :: equal => rules :: equal (state) , Rule :: left_column => rules :: left_column (state) , Rule :: right_column => rules :: right_column (state) , Rule :: stmtx => rules :: stmtx (state) , Rule :: stmt => rules :: stmt (state) , Rule :: literal_if => rules :: literal_if (state) , Rule :: literal_while => rules :: literal_while (state) , Rule :: literal_loop => rules :: literal_loop (state) , Rule :: literal_else => rules :: literal_else (state) , Rule :: expx => rules :: expx (state) , Rule :: exp => rules :: exp (state) , Rule :: binary_exp => rules :: binary_exp (state) , Rule :: import_decl => rules :: import_decl (state) , Rule :: struct_decl => rules :: struct_decl (state) , Rule :: procedure_body => rules :: procedure_body (state) , Rule :: procedure_decl => rules :: procedure_decl (state) , Rule :: module_decl => rules :: module_decl (state) , Rule :: transaction_script => rules :: transaction_script (state) , Rule :: move_script => rules :: move_script (state) , Rule :: script_def => rules :: script_def (state) , Rule :: address_def => rules :: address_def (state) , Rule :: module_def => rules :: module_def (state) , Rule :: moduleitem_item => rules :: moduleitem_item (state) , Rule :: const_def => rules :: const_def (state) , Rule :: nat_function_def => rules :: nat_function_def (state) , Rule :: nat_struct_def => rules :: nat_struct_def (state) , Rule :: function_sig_withoptionalvisibility => rules :: function_sig_withoptionalvisibility (state) , Rule :: function_sig_visibility => rules :: function_sig_visibility (state) , Rule :: function_sig_ => rules :: function_sig_ (state) , Rule :: function_def => rules :: function_def (state) , Rule :: function_visibilitymodifier => rules :: function_visibilitymodifier (state) , Rule :: function_parameterlist => rules :: function_parameterlist (state) , Rule :: function_parameter => rules :: function_parameter (state) , Rule :: returntype => rules :: returntype (state) , Rule :: acquirestype => rules :: acquirestype (state) , Rule :: acquirestype_items => rules :: acquirestype_items (state) , Rule :: acquirestype_items_recover => rules :: acquirestype_items_recover (state) , Rule :: struct_sig_ => rules :: struct_sig_ (state) , Rule :: struct_def => rules :: struct_def (state) , Rule :: abilitieslist => rules :: abilitieslist (state) , Rule :: ability => rules :: ability (state) , Rule :: structfields_defblock => rules :: structfields_defblock (state) , Rule :: structfield_def => rules :: structfield_def (state) , Rule :: friend_stmt => rules :: friend_stmt (state) , Rule :: import_stmt => rules :: import_stmt (state) , Rule :: module_import => rules :: module_import (state) , Rule :: module_items_import => rules :: module_items_import (state) , Rule :: multi_item_import => rules :: multi_item_import (state) , Rule :: item_import => rules :: item_import (state) , Rule :: importalias => rules :: importalias (state) , Rule :: typeannotation => rules :: typeannotation (state) , Rule :: type_ => rules :: type_ (state) , Rule :: reftype => rules :: reftype (state) , Rule :: reftypestart => rules :: reftypestart (state) , Rule :: qual_pathtype => rules :: qual_pathtype (state) , Rule :: tupletype => rules :: tupletype (state) , Rule :: lambdatype => rules :: lambdatype (state) , Rule :: typeparameterlist => rules :: typeparameterlist (state) , Rule :: typeparameter_with_recover => rules :: typeparameter_with_recover (state) , Rule :: typeparameter_recover => rules :: typeparameter_recover (state) , Rule :: typeparameter => rules :: typeparameter (state) , Rule :: typeparambound => rules :: typeparambound (state) , Rule :: typeparambound_items => rules :: typeparambound_items (state) , Rule :: typeargumentlist => rules :: typeargumentlist (state) , Rule :: _pat => rules :: _pat (state) , Rule :: wild_pat => rules :: wild_pat (state) , Rule :: deref_pat => rules :: deref_pat (state) , Rule :: borrow_pat => rules :: borrow_pat (state) , Rule :: dot_pat => rules :: dot_pat (state) , Rule :: binding_pat => rules :: binding_pat (state) , Rule :: tuple_pat => rules :: tuple_pat (state) , Rule :: struct_pat => rules :: struct_pat (state) , Rule :: struct_patfieldsblock => rules :: struct_patfieldsblock (state) , Rule :: struct_patfield => rules :: struct_patfield (state) , Rule :: struct_patfieldbinding => rules :: struct_patfieldbinding (state) , Rule :: _stmt => rules :: _stmt (state) , Rule :: let_stmt => rules :: let_stmt (state) , Rule :: _stmt_expr => rules :: _stmt_expr (state) , Rule :: anyblock => rules :: anyblock (state) , Rule :: inlineblock => rules :: inlineblock (state) , Rule :: codeblock_expr => rules :: codeblock_expr (state) , Rule :: codeblock => rules :: codeblock (state) , Rule :: codeblockitems => rules :: codeblockitems (state) , Rule :: _expr => rules :: _expr (state) , Rule :: _exprx => rules :: _exprx (state) , Rule :: _expr_op => rules :: _expr_op (state) , Rule :: controlflow_expr => rules :: controlflow_expr (state) , Rule :: unary_expr => rules :: unary_expr (state) , Rule :: atom_expr => rules :: atom_expr (state) , Rule :: annotatedexpprefix => rules :: annotatedexpprefix (state) , Rule :: annotated_expr => rules :: annotated_expr (state) , Rule :: bang_expr => rules :: bang_expr (state) , Rule :: deref_expr => rules :: deref_expr (state) , Rule :: copy_expr => rules :: copy_expr (state) , Rule :: move_expr => rules :: move_expr (state) , Rule :: return_expr => rules :: return_expr (state) , Rule :: abort_expr => rules :: abort_expr (state) , Rule :: break_expr => rules :: break_expr (state) , Rule :: continue_expr => rules :: continue_expr (state) , Rule :: structliteral_expr => rules :: structliteral_expr (state) , Rule :: structliteral_fieldsblock => rules :: structliteral_fieldsblock (state) , Rule :: structliteral_field => rules :: structliteral_field (state) , Rule :: structliteral_fieldassignment => rules :: structliteral_fieldassignment (state) , Rule :: parens_expr => rules :: parens_expr (state) , Rule :: lambda_expr => rules :: lambda_expr (state) , Rule :: range_expr => rules :: range_expr (state) , Rule :: tupleliteral_expr => rules :: tupleliteral_expr (state) , Rule :: emptytuple_expr => rules :: emptytuple_expr (state) , Rule :: tuple_expr => rules :: tuple_expr (state) , Rule :: literal_expr => rules :: literal_expr (state) , Rule :: call_expr => rules :: call_expr (state) , Rule :: callarguments => rules :: callarguments (state) , Rule :: if_expr => rules :: if_expr (state) , Rule :: condition => rules :: condition (state) , Rule :: conditionbody => rules :: conditionbody (state) , Rule :: elseblock => rules :: elseblock (state) , Rule :: loop_expr => rules :: loop_expr (state) , Rule :: while_expr => rules :: while_expr (state) , Rule :: borrow_expr => rules :: borrow_expr (state) , Rule :: dot_expr => rules :: dot_expr (state) , Rule :: structfieldref => rules :: structfieldref (state) , Rule :: index_expr => rules :: index_expr (state) , Rule :: ref_expr => rules :: ref_expr (state) , Rule :: qual_path => rules :: qual_path (state) , Rule :: moduleref => rules :: moduleref (state) , Rule :: fullyqualifiedmoduleref => rules :: fullyqualifiedmoduleref (state) , Rule :: spec_def => rules :: spec_def (state) , Rule :: schemaspec_def => rules :: schemaspec_def (state) , Rule :: function_spec_def => rules :: function_spec_def (state) , Rule :: structspec_def => rules :: structspec_def (state) , Rule :: modulespec_def => rules :: modulespec_def (state) , Rule :: _definefunction_sig_ => rules :: _definefunction_sig_ (state) , Rule :: _definefunction_ => rules :: _definefunction_ (state) , Rule :: nat_definefunction_ => rules :: nat_definefunction_ (state) , Rule :: blockspec_stmt => rules :: blockspec_stmt (state) , Rule :: specblock => rules :: specblock (state) , Rule :: specblock_stmt => rules :: specblock_stmt (state) , Rule :: specblockfinishing_expr => rules :: specblockfinishing_expr (state) , Rule :: _definefunction_spec_def => rules :: _definefunction_spec_def (state) , Rule :: nat_definefunction_spec_def => rules :: nat_definefunction_spec_def (state) , Rule :: variable_stmt => rules :: variable_stmt (state) , Rule :: localvariable_stmt => rules :: localvariable_stmt (state) , Rule :: globalvariable_stmt => rules :: globalvariable_stmt (state) , Rule :: pragma_stmt => rules :: pragma_stmt (state) , Rule :: pragmaattribute => rules :: pragmaattribute (state) , Rule :: spec_expr => rules :: spec_expr (state) , Rule :: assume_stmt => rules :: assume_stmt (state) , Rule :: assumespec_expr => rules :: assumespec_expr (state) , Rule :: assert_stmt => rules :: assert_stmt (state) , Rule :: assertspec_expr => rules :: assertspec_expr (state) , Rule :: abortsif_stmt => rules :: abortsif_stmt (state) , Rule :: abortsifspec_expr => rules :: abortsifspec_expr (state) , Rule :: with_expr => rules :: with_expr (state) , Rule :: succeedsif_stmt => rules :: succeedsif_stmt (state) , Rule :: succeedsifspec_expr => rules :: succeedsifspec_expr (state) , Rule :: requires_stmt => rules :: requires_stmt (state) , Rule :: requiresspec_expr => rules :: requiresspec_expr (state) , Rule :: ensures_stmt => rules :: ensures_stmt (state) , Rule :: ensuresspec_expr => rules :: ensuresspec_expr (state) , Rule :: modifies_stmt => rules :: modifies_stmt (state) , Rule :: modifiesspec_expr => rules :: modifiesspec_expr (state) , Rule :: include_stmt => rules :: include_stmt (state) , Rule :: function_pattern => rules :: function_pattern (state) , Rule :: invariant_stmt => rules :: invariant_stmt (state) , Rule :: invariantspec_expr => rules :: invariantspec_expr (state) , Rule :: invariantmodifier => rules :: invariantmodifier (state) , Rule :: spec_visibility => rules :: spec_visibility (state) , Rule :: spec_visibilitymodifier => rules :: spec_visibilitymodifier (state) , Rule :: emits_stmt => rules :: emits_stmt (state) , Rule :: emits_condition => rules :: emits_condition (state) , Rule :: apply_stmt => rules :: apply_stmt (state) , Rule :: apply_schema_name => rules :: apply_schema_name (state) , Rule :: apply_schema_name_attribute => rules :: apply_schema_name_attribute (state) , Rule :: predicate => rules :: predicate (state) , Rule :: aggregatepredicate_stmt => rules :: aggregatepredicate_stmt (state) , Rule :: aggregate_expr => rules :: aggregate_expr (state) , Rule :: quant_where => rules :: quant_where (state) , Rule :: quant_expr => rules :: quant_expr (state) , Rule :: forall_quant => rules :: forall_quant (state) , Rule :: exist_quant => rules :: exist_quant (state) , Rule :: quant_bindings => rules :: quant_bindings (state) , Rule :: quant_bind => rules :: quant_bind (state) , Rule :: EOI => rules :: EOI (state) } }) } }
