// move grammar
// Copyright (c) 2021 Yiwei Yang
//
// Licensed under the Apache License, Version 2.0
// <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0> or the MIT
// license <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. All files in the project carrying such notice may not be copied,
// modified, or distributed except according to those terms.

grammar_rules = _{ SOI ~ grammar_rule ~ EOI }

grammar_rule = {module_decl|transaction_script|move_script}


line_terminator = _{ "\u{000A}" | "\u{000D}" | "\u{2028}" | "\u{2029}" }
WHITESPACE = _{
  "\u{0009}" |
  "\u{000B}" |
  "\u{000C}" |
  "\u{0020}" |
  "\u{00A0}" |
  "\u{FEFF}" |
  SPACE_SEPARATOR |
  line_terminator
}
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" | "//"~ANY* }

alpha={ 'a'..'z' | 'A'..'Z' }
digit={ '0'..'9' }
ident = { (alpha|digit|"$"|"_") ~ (alpha|digit|"$"|"_")*}
field_name = {ident}
procedure_name = {ident}
module_name = {ident}
struct_name = {ident}
var = {ident}

// Types
kind = {"R"|"V"}
ground_type = {"bool"|"u8"|"u32"|"u64"|"u128"|"address"|"bytearray"}
module_alias = {module_name|"Self"}
base_type = {ground_type|kind~"#"~module_alias~"."~struct_name }
type_ = {base_type|"&"~base_type|"&mut"~base_type}
tau_list = {"unit"| (type_) *}

// Values
unsigned = {digit*}
address = {"0x"~('0'..'9'|'a'..'f'|'A'..'F')*}
bytes = {"b\""~(alpha|digit)*~"\""}
value = {"true"|"false"|address|bytes|unsigned}
SENDER_address={"{{sender}}"}

// Expression
value_operator = {"copy"~"("~var~")" | "move"~"("~var~")"}
reference_operator = {"&"~var|"&"~exp~"."~field_name|"*"~exp}

// Commands
module_operator = {"move_from"~"<"~struct_name~">"~"("~exp~")"|"borrow_global"~"<"~struct_name~">"~"("~exp~")"|"exist"~"<"~struct_name~">"~"("~exp~")"}
builtin = {"create_account"~"("~exp~")"|"release"~"("~exp~")"|"freeze"~"("~exp~")"}
call = {module_operator|builtin|module_alias~"."~procedure_name~"("~((exp~",") *~exp)?~")"}
cmd = {var~"="~call|var*~"="~exp|call|"*"~var~"="~exp|"assert"~"("~exp~","~exp~")"|"break"|"continue"|"return"~((exp~",")*~exp)?|struct_name ~"{"~((field_name~":"~var~",")*~field_name~":"~var)?~"}"~"="~exp}
stmtx = {stmt~stmtx|stmt}
stmt = {"if"~"("~exp~")"~"{" ~stmtx~ "}"~"else"~"{"~stmtx~"}"|"if"~"("~exp~")"~"{"~stmtx~"}"|"while"~"("~exp~")"~"{"~stmtx~"}" |"loop"~"{"~stmtx~"}"| cmd~";"}
expx = {value_operator|reference_operator|struct_name~"{"~(field_name~":"~expx)* ~"}"|"!"~expx|value}
exp = {expx~"||"~exp|expx~"&&"~exp|expx~">="~exp|expx~"<="~exp|expx~">"~exp|expx~"<"~exp|expx~"+"~exp|expx~"-"~exp|expx~"*"~exp|expx~"/"~exp|expx~"*"~exp|expx~"%"~exp|expx~"^"~exp|expx~"|"~exp|expx~"&"~exp|expx~"=="~exp|expx~"!="~exp|"("~exp~")"~exp|"("~exp~")"|expx}

// Imports
import_decl = {"import"~address~"."~module_name~"as"~module_name~";"|"import"~address~"."~module_name~";"}

// Modules
struct_decl = {"resourse"~struct_name~"{" ~(field_name~":"~base_type~",")*~field_name~":"~base_type~" }"|"struct"~struct_name~"{"~((field_name~":"~base_type~",")*~field_name~":"~base_type)?~"}"}
procedure_body = {("let"~var~(":"~ground_type)?~";")*~stmtx}
procedure_decl = {"public"?~procedure_name~"(" ~((var~":"~type_~",")*~var~":"~type_)?~")"~":"~tau_list~"{" ~procedure_body~"}" |"native"~"public"? ~procedure_name~"(" ~((var~":"~type_~",")*~var~":"~type_)?~")"~":"~tau_list~";"}
module_decl = {"module"~module_name~"{"~import_decl*~struct_decl*~procedure_decl*~"}"}

// Transaction Scripts
transaction_script = {import_decl*~"public"~"main"~"("~((var~":"~ground_type~",")*~var~":"~ground_type)?~")"}

// Move script
move_script = {(ScriptDef | AddressDef | ModuleDef)*}

ScriptDef = {"script"~ScriptBlock} 
ScriptBlock = {"{"~ScriptBlockItems~"}"}
ScriptBlockItems = {ScriptItem*}

ScriptItem = {!("}"| EOI)~ScriptItem_item}
ScriptItemFirst = {"use" | "const" | "fun"}
ScriptItem_recover = {!("}" | EOI | ScriptItemFirst)}

ScriptItem_item = {ImportStatement | ConstDef | FunctionDef}

AddressDef ={ "address"~AddressRef~AddressBlock }
AddressBlock = {"{"~AddressBlockItems~"}" }
AddressBlockItems = {ModuleDef*}
AddressBlockItems_recover = {!"}"}

ModuleDef = {"module"~ident~ModuleBlock}
ModuleBlock = {"{"~ModuleBlockItems~"}"}
ModuleBlockItems = {ModuleItem*}

ModuleItem ={ !("}" | EOI)~ModuleItem_item}
Item_first = {"use" | "public" | "native" | "fun" | "const" | "struct" | "spec"}
Item_recover = {!("}" | Item_first)}

ModuleItem_item = {ImportStatement | FriendStatement
                            | StructDef | FunctionDef
                            | NativeStructDef | NativeFunctionDef
                            | ConstDef
                            | SpecDef}

ConstDef = {"const"~ident~TypeAnnotation~Initializer~";"}

NativeFunctionDef = {"native"~FunctionSignatureWithOptionalVisibility~";" }
NativeStructDef = {"native"~StructSignature~";"}

FunctionSignatureWithOptionalVisibility = {FunctionSignatureVisibility | FunctionSignature}
FunctionSignatureVisibility = {FunctionVisibilityModifier~FunctionSignature }
FunctionSignature = {"fun"~ident~TypeParameterList?~FunctionParameterList~ReturnType?~AcquiresType?}
FunctionSignature__recover = {!("{" | "}" | ";" | EOI | Item_first)}
FunctionDef = {FunctionSignatureWithOptionalVisibility~CodeBlock}

FunctionVisibilityModifier = {"public"~("("~("script" | "friend")~")")?}

FunctionParameterList = {"(" ~((FunctionParameter~",")*~FunctionParameter)?~ ")"}

FunctionParameter = {ident~TypeAnnotation}
ReturnType = {":"~ReturnTypeItem_with_recover} 
ReturnTypeItem_with_recover = {Type}
ReturnTypeItem_recover = {!( "{" | ";" | "acquires" )}

/// acquires T, Record
AcquiresType = {"acquires"~ AcquiresType_items} 
AcquiresType_items = { ((QualPathType~",") *~QualPathType)? }
AcquiresType_items_recover = {!(";" | "{")}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Structs
////////////////////////////////////////////////////////////////////////////////////////////////////
StructSignature = {"struct"~ident~TypeParameterList?~AbilitiesList?}

StructDef = {StructSignature~StructFieldsDefBlock}

AbilitiesList = {"has"~((Ability~",") *~Ability)? }
Ability = {"copy" | ident}

StructFieldsDefBlock = {"{"~StructFieldDef_with_recover*~"}" }
StructFieldDef_with_recover = {!"}"~StructFieldDef~("," | &"}")}
StructFieldDef_recover = {!("}" | ident)}

StructFieldDef = {ident~TypeAnnotation~("," | "}")}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Imports
////////////////////////////////////////////////////////////////////////////////////////////////////
FriendStatement = {"friend"~FullyQualifiedModuleRef~";" }

ImportStatement = {"use"~(ModuleItemsImport | ModuleImport)~";"}

ModuleImport = {FullyQualifiedModuleRef~ImportAlias?}
ModuleItemsImport = {FullyQualifiedModuleRef~"::"~(ItemImport | MultiItemImport)}

MultiItemImport = {"{"~ ((MultiItemImport_member_with_recovery~",")*~MultiItemImport_member_with_recovery)?~"}"}
MultiItemImport_member_with_recovery = {!("}" | ";" | EOI)~ItemImport}

ItemImport = {ident~ImportAlias?}

ImportAlias = {"as"~ ident}

// ///////////////////////////////////////////////////////////////////////////////////////////////////
// // Types
// ///////////////////////////////////////////////////////////////////////////////////////////////////
TypeAnnotation = {":"~Type} 

Type = {RefType | QualPathType | TupleType | LambdaType}

RefType = {RefTypeStart~Type}
RefTypeStart = {"&"~"mut"?}
QualPathType = {QualPath}

TupleType = {"("~TupleTypeItem_with_recover*~")"} 
TupleTypeItem_with_recover = {!")"~Type~("," | &")")}
TupleTypeItem_recover = {!(")" | "{" | ident)}

LambdaType = {"|"~((Type~",") *~Type)?~"|"~Type }
TypeParameterList = {"<"~TypeParameter_with_recover*~">"}
TypeParameter_with_recover = {!">"~TypeParameter~("," | &">")}
TypeParameter_recover = {!(">" | "(" | "{" | ident)}
TypeParameter = {ident~TypeParamBound?}
TypeParamBound = {":"~TypeParamBound_items}
TypeParamBound_items = {Ability~( "+"~Ability )*}
TypeParamBound_items_recover = {!(">" | ",")}

TypeArgumentList = {"<"~(((TypeArgument ~(","|">"))~",") *~(TypeArgument ~(","|">")))? ~">"}
TypeArgument = {Type}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Patterns (destructuring)
////////////////////////////////////////////////////////////////////////////////////////////////////
Pat = {DerefPat
        | BorrowPat
        | TuplePat
        | StructPat
        | DotPat
        | WildPat
        | BindingPat}

WildPat ={"~_"}
DerefPat ={"*"~ Pat}
BorrowPat ={"&"~ Pat}
DotPat ={ident~ "."~ ident}

BindingPat = {ident}

TuplePat = {"(" ~((Pat~",") *~Pat)? ~")"}

StructPat ={ QualPath~StructPatFieldsBlock }
StructPatFieldsBlock = {"{"~StructPatField_with_recover*~"}" }

StructPatField_with_recover = {!"}"~StructPatField~("," | "}")}
StructPatField_recover = {!("}" | ident)}
StructPatField = {ident~StructPatFieldBinding? }
StructPatFieldBinding ={ ":"~Pat }

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Statements
////////////////////////////////////////////////////////////////////////////////////////////////////
Statement ={ LetStatement | (StatementExpr~";")}
LetStatement = {"let"~Pat~TypeAnnotation?~Initializer?~";" }
StatementExpr = {IfExpr | LoopExpr | WhileExpr | Expr}
AnyBlock = {CodeBlock | InlineBlock}

InlineBlock = {Expr}

CodeBlockExpr = {CodeBlock}
CodeBlock = {"{"~CodeBlockItems~ "}"}


CodeBlockItems = {ImportStatement*~(Statement | BlockSpecStatement)*~Expr?}
CodeBlockItems_recover = {!"}"}

/////////////////////////////////////////////////////////////////////////////////////////////////////
/// Expressions
////////////////////////////////////////////////////////////////////////////////////////////////////
Expr = {AssignmentExpr
        | ImplyOperatorsExprItem
        | OrExpr
        | AndExpr
        | LogicalEqExprItem
        | BitOrExpr
        | BitXorExpr
        | BitAndExpr
        | (LeftShiftExpr | RightShiftExpr)
        | AddExprItem
        | MulExprItem
        | ControlFlowExpr
        | CastExpr
        | UnaryExpr
        | BorrowExpr
        | AtomExpr}

MulExprItem = {DivExpr | MulExpr | ModExpr}
AddExprItem = {PlusExpr | MinusExpr}
LogicalEqExprItem = {EqualsExpr | NotEqualsExpr | LessEqualsExpr | LessExpr | GreaterEqualsExpr | GreaterExpr}

ControlFlowExpr ={ IfExpr | LoopExpr | WhileExpr}
UnaryExpr = {CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr}
AtomExpr ={ AnnotatedExpr
                    | TupleLiteralExpr
                    | ParensExpr
                    | StructLiteralExpr
                    | DotExpr
                    | IndexExpr
                    | CallExpr
                    | RefExpr
                    | LambdaExpr
                    | RangeExpr
                    | CodeBlockExpr | LiteralExpr}

EqualsExpr ={ Expr~"=="~Expr}
NotEqualsExpr = {Expr~"!="~Expr}

OrExpr = {Expr~"||"~Expr}
AndExpr = {Expr~"&&"~Expr}

LessExpr = {Expr~(!("<<" | "<==>")~"<")~Expr}
GreaterExpr ={ Expr~(!">>"~">")~Expr}
LessEqualsExpr = {Expr~"<="~Expr}
GreaterEqualsExpr = {Expr~">="~Expr}

BitOrExpr = {Expr~(!"||"~ "|")~Expr}
BitAndExpr = {Expr~(!"&&"~"&")~Expr}
BitXorExpr ={ Expr~"^"~Expr}

CastExpr ={ Expr ~"as"~ Type}


AnnotatedExpPrefix = {"("~Expr~":"}
AnnotatedExpr = {AnnotatedExpPrefix~Type~")" }

MulExpr = {Expr~"*"~Expr}

DivExpr = {Expr~"/"~Expr}
PlusExpr = {Expr~"+"~Expr}
MinusExpr = {Expr~"-"~Expr}
ModExpr = {Expr~"%"~Expr}
LeftShiftExpr = {Expr~"<<"~Expr}
RightShiftExpr = {Expr~">>"~Expr}

ImplyOperatorsExprItem = {ImplyOperatorExpr | PartialImplyOperatorExpr}
ImplyOperatorExpr = {Expr~"==>"~Expr}
PartialImplyOperatorExpr = {Expr~"<==>"~Expr}

BangExpr = {"!" ~Expr}
DerefExpr = {"*"~ Expr}

CopyExpr = {"copy" ~Expr}
MoveExpr = {"move" ~Expr}


ReturnExpr = {"return"~Expr?}
AbortExpr = {"abort"~Expr}
BreakExpr = {"break"}
ContinueExpr = {"continue"}

StructLiteralExpr = {QualPath~StructLiteralFieldsBlock}

StructLiteralFieldsBlock = {"{"~StructLiteralField_with_recover*~"}" }

StructLiteralField_with_recover = {!"}"~StructLiteralField~("," | &"}")}

StructLiteralField_recover ={ !("}" | ident)}

StructLiteralField = {ident~StructLiteralFieldAssignment?}

StructLiteralFieldAssignment = {":"~Expr }

ParensExpr = {"("~Expr~")"}

LambdaExpr = {"|" ~((ident~",") *~ident)? ~"|"~ Expr }
RangeExpr = {Expr~".."~Expr}

TupleLiteralExpr = {EmptyTupleExpr | TupleExpr}
EmptyTupleExpr = {"("~")"}
TupleExpr = {"("~((Expr~",")*~Expr)?~")"}

LiteralExpr = { SENDER_address
                | address | value }
CallExpr = {QualPath ~"("~CallArguments}
CallArguments ={ "("~  (Expr~&(","|")"))?~ ")" }

IfExpr = {"if"~Condition~AnyBlock~ElseBlock?}

Condition = {"("~ConditionBody~")"}
ConditionBody = {Expr}
ConditionBody_recover = {!")"}

ElseBlock = {"else"~AnyBlock} 
LoopExpr = {"loop"~AnyBlock} 
WhileExpr = {"while"~Condition~AnyBlock}

AssignmentExpr ={ Expr~Initializer}
Initializer ={ "="~Expr }

BorrowExpr = {"&"~"mut"?~Expr}

DotExpr = {Expr~"."~StructFieldRef}

StructFieldRef = {ident}

IndexExpr = {Expr~"["~Expr~"]" }
RefExpr = {QualPath}
QualPath = {(ModuleRef~"::")?~ident~TypeArgumentList?}

ModuleRef = {ImportedModuleRef | FullyQualifiedModuleRef}

ImportedModuleRef = {ident}

FullyQualifiedModuleRef = {AddressRef~"::"~ident}

AddressRef = {SENDER_address
                | address}

// ///////////////////////////////////////////////////////////////////////////////////////////////////
// // Specs
// ///////////////////////////////////////////////////////////////////////////////////////////////////
SpecDef = {FunctionSpecDef
                  | ModuleSpecDef
                  | StructSpecDef
                  | SchemaSpecDef
                  | DefineFunctionSpecDef
                  | NativeDefineFunctionSpecDef}

SchemaSpecDef = {("spec"|"schema")~ident~TypeParameterList?~SpecBlock }

FunctionSpecDef ={("spec"|"fun")~ident~SpecBlock}

StructSpecDef = {("spec"|"struct")~ident~SpecBlock}

ModuleSpecDef = {("spec"|"module")~SpecBlock}

DefineFunctionSignature = {"define"~ident~TypeParameterList?~FunctionParameterList~ReturnType?}


DefineFunction ={ DefineFunctionSignature~SpecBlock}

NativeDefineFunction = {DefineFunctionSignature~";"}

BlockSpecStatement = {"spec"~SpecBlock~";" }

SpecBlock = {"{"~SpecBlockStatement_with_recover*~SpecBlockFinishingExpr_with_recover?~"}"}
SpecBlockStatement_with_recover = { !("}" | EOI) ~ SpecBlockStatement }
SpecBlockFinishingExpr_with_recover = {!("}" |EOI) ~SpecBlockFinishingExpr}
SpecBlockStatement = {VariableStatement | LocalVariableStatement | GlobalVariableStatement
                              | ImportStatement
                              | NativeFunctionDef
                              | DefineFunction | DefineFunctionSpecDef
                              | NativeDefineFunction | NativeDefineFunctionSpecDef
                              | PragmaStatement
                              | AssumeStatement
                              | AssertStatement
                              | AbortsIfStatement
                              | SucceedsIfStatement
                              | RequiresStatement
                              | EnsuresStatement
                              | ModifiesStatement
                              | IncludeStatement
                              | InvariantStatement
                              | ApplyStatement
                              | EmitsStatement
                              | AggregatePredicateStatement
                              | Statement}
SpecBlockFinishingExpr = {SpecExpr | AggregateExpr | Expr}

DefineFunctionSpecDef = {"spec" ~DefineFunctionSignature ~SpecBlock}
NativeDefineFunctionSpecDef = {"spec"~DefineFunctionSignature~";" }
VariableStatement = {RefExpr~TypeAnnotation~";"}

LocalVariableStatement = {"local"~RefExpr~TypeAnnotation~";"}
GlobalVariableStatement = {"global"~RefExpr~TypeAnnotation~";" }

PragmaStatement = {"pragma"~((PragmaAttribute~",")*~PragmaAttribute)?~";" }
PragmaAttribute = {ident~("="~LiteralExpr)?}

SpecExpr = {AssumeSpecExpr | AssertSpecExpr | AbortsIfSpecExpr | SucceedsIfSpecExpr
                | RequiresSpecExpr | EnsuresSpecExpr | ModifiesSpecExpr | InvariantSpecExpr}

AssumeStatement = {AssumeSpecExpr~";"}
AssumeSpecExpr = {"assume"~Predicate} 

AssertStatement = {AssertSpecExpr~";"}
AssertSpecExpr = {"assert"~Predicate}

AbortsIfStatement = {AbortsIfSpecExpr~";"}
AbortsIfSpecExpr = {"aborts_if"~Predicate~WithExpr? }
WithExpr = {"with"~Expr} 

SucceedsIfStatement = {SucceedsIfSpecExpr~";"}
SucceedsIfSpecExpr = {"succeeds_if"~Predicate} 

RequiresStatement = {RequiresSpecExpr~";"}
RequiresSpecExpr = {"requires"~"module"?~Predicate }

EnsuresStatement = {EnsuresSpecExpr~";"}
EnsuresSpecExpr = {"ensures"~Predicate }

ModifiesStatement = {ModifiesSpecExpr~";"}
ModifiesSpecExpr = {"modifies"~Expr }

IncludeStatement = {"include"~SpecVisibility?~Expr~";" }

FunctionPattern = {("public" | "internal")?~ident~TypeArgumentList? }

InvariantStatement = {InvariantSpecExpr~";"}
InvariantSpecExpr = {"invariant"~InvariantModifier?~Predicate }
InvariantModifier = {"pack" | "unpack" | "module" | "update"}

SpecVisibility = {"[" ~((SpecVisibilityModifier~",")*~SpecVisibilityModifier)?~"]"}
SpecVisibilityModifier = {"global" | "isolated" | "deactivated"
                                | "concrete" | "abstract"
                                | "assert" | "assume"}

EmitsStatement = {"emits"~Expr~"to"~Expr~EmitsCondition?~";" }
EmitsCondition = {"if"~Expr }
ApplyStatement = {"apply"~ApplySchemaName~"to"~((FunctionPattern~",")*~FunctionPattern)?~("except"~ ((FunctionPattern~",")*~FunctionPattern)? )?~";"}

ApplySchemaName ={ QualPath~("{"~ ((ApplySchemaNameAttribute~",")*~ApplySchemaNameAttribute)?~ "}")?}

ApplySchemaNameAttribute = {ident~":"~Expr}

Predicate = {SpecVisibility?~(AggregateExpr | Expr )}
AggregatePredicateStatement = {AggregateExpr~";"}
AggregateExpr = {QuantifierExpr~(":"~ Expr)?}

QuantifierWhere = {"where"~Expr}
QuantifierExpr = {ForallQuantifier | ExistsQuantifier}
ForallQuantifier = {"forall"~QuantifierBindings~(QuantifierWhere)?~(":" ~QuantifierExpr)? }
ExistsQuantifier = {"exists"~QuantifierBindings~(QuantifierWhere)?~(":" ~QuantifierExpr)? }

QuantifierBindings = {((QuantifierBind~",")*~QuantifierBind)?}
QuantifierBind = {RangeQuantifierBind | TypeQuantifierBind}

RangeQuantifierBind = {ident~"in"~RangeExpr }

TypeQuantifierBind = {ident~":"~Type} 